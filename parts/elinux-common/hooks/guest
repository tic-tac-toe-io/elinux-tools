#!/bin/bash
#

# Here are variables initiated by load_and_run script:
#
#  - PART_NAME
#  - PART_DIR
#
# Here are variables initiated by apply_parts command,
# stored in ${WORK_DIR}/env.bash
# 
#  - AD_BUILD_WORK_TOPDIR           , e.g. /tmp/elinux-tools/apply_parts_20170409164024
#  - AD_BUILD_WORK_DEBIAN_PKG_LIST  , e.g. /tmp/elinux-tools/apply_parts_20170409164024/package-debian.txt
#  - AD_BUILD_WORK_PYTHON2_PKG_LIST , e.g. /tmp/elinux-tools/apply_parts_20170409164024/package-python2.txt
#  - AD_BUILD_WORK_PYTHON3_PKG_LIST ' e.g. /tmp/elinux-tools/apply_parts_20170409164024/package-python3.txt
#  - CLI_DIR
#  - ELINUX_TOOLS_DIR
#
#  (Following variables are retrieved from ${ARCHIVE_DIR}/rootfs.yaml)
#  - BOARD_DIST_CODENAME   bone, raspbian, ...
#  - DIST_CODENAME         trusty, jessie, ...
#  - DIST_NAME             ubuntu, debian, ...
#  - KERNEL_ARCHITECTURE   armv7l
#  - KERNEL                linux
#  - KERNEL_VERSION        4.1.17-ti-rt-r47
#
#  (Following variables are retrieved from the config.json passed to apply_parts subcommand, all are optional)
#  - BOARD                 bbgw, bbg, piz, pizw, ...
#  - BOARD_ENV             production, testing, development, ...
#  - BOARD_PROFILE         abc, def, spider, ...
#
# 


function install_debian_packages {
	local PKG_FILE=$1
	NO_TAB="true" run_my_cmd "apt-get update"
	NO_TAB="true" run_my_cmd "apt-get install -y $(cat ${PKG_FILE} | tr '\n' ' ')"
}


function install_python_packages {
	local PY_VERSION=$1
	local PY_PKG_FILE=$2
	[ ! -f "${PY_PKG_FILE}" ] && return 1

	local TMP_FILE=$(mktemp /tmp/XXXXXX)
	cat ${PY_PKG_FILE} | grep -v "^#" | grep -v "^$" > ${TMP_FILE}
	[ "0" == "$(cat ${TMP_FILE} | wc -l)" ] && rm -f ${TMP_FILE} && return 2

	local PIP="pip"
	local EASY_INSTALL="easy_install"
	[ "python3" == "${PY_VERSION}" ] && PIP="pip3" && EASY_INSTALL="easy_install3"
	
	run_my_cmd "${EASY_INSTALL} --version"
	run_my_cmd "${PIP} install --upgrade setuptools"
	run_my_cmd "${PIP} install $(cat ${TMP_FILE} | tr '\n' ' ')"
	local EXIT_CODE=$?
	rm -f ${TMP_FILE}
	return ${EXIT_CODE}
}


function install_all_packages {
	local TMP_FILE=$(mktemp /tmp/XXXXXX)
	cat ${AD_BUILD_WORK_DEBIAN_PKG_LIST} | grep -v "^#" > ${TMP_FILE}
	[ -f "${AD_BUILD_WORK_PYTHON2_PKG_LIST}" ] && [ "0" != "$(cat ${AD_BUILD_WORK_PYTHON2_PKG_LIST}) | wc -l)" ] && echo "python-pip" >> ${TMP_FILE}
	[ -f "${AD_BUILD_WORK_PYTHON3_PKG_LIST}" ] && [ "0" != "$(cat ${AD_BUILD_WORK_PYTHON3_PKG_LIST}) | wc -l)" ] && echo "python3-pip" >> ${TMP_FILE}

	local EXIT_CODE="0"

	if [ "0" != "$(cat ${TMP_FILE} | wc -l)" ]; then
		case "${DIST_NAME}" in
			ubuntu|debian)
				install_debian_packages ${TMP_FILE}
				EXIT_CODE=$?; [ "0" != "${EXIT_CODE}" ] && return ${EXIT_CODE}
				;;
			*)
				ERR "unsupported linux distribution: ${DIST_NAME}"
				return 1
				;;
		esac
	fi
	rm -f ${TMP_FILE}

	install_python_packages python2 ${AD_BUILD_WORK_PYTHON2_PKG_LIST}
	install_python_packages python3 ${AD_BUILD_WORK_PYTHON3_PKG_LIST}
}


function run_service_useradd {
	local DIR=$1
	INFO "run_service_useradd: ${DIR}"
	ls -al ${DIR}
	find ${DIR} -type f | awk '{printf "\t%s\n", $0}'
	return 0
}


function run_service_hello {
	local DIR=$1
	find ${DIR} -type f | awk '{printf "\t%s\n", $0}'
	return 0
}


function run_all_services {
	local CHROOT_WORK_PART_SERVICE_DIR="${AD_BUILD_WORK_TOPDIR}/${PART_NAME}/services"
	local SERVICES=($(cat ${BASH_SOURCE[0]} | grep "^function run_service_" | awk '{print $2}' | sed 's/^run_service_//g'))
	for service in "${SERVICES[@]}"; do
		local SERVICE_DIR="${CHROOT_WORK_PART_SERVICE_DIR}/${service}"
		[ ! -d "${SERVICE_DIR}" ] && continue
		INFO "service: ${service}"
		run_service_${service} ${SERVICE_DIR}
		local EXIT_CODE=$?
		[ "0" != "${EXIT_CODE}" ] && ERR "failed to run ${service} service, exit: ${EXIT_CODE}" && return ${EXIT_CODE}
	done
	return 0
}


function generate_part_bash_env {
cat <<__EOF__ > $2
## Derived from ${ENV_BASH}
#
$(cat ${ENV_BASH})

## Merged from ${AD_BUILD_WORK_PARTS_DIR}/$1.env.bash
#
$(cat ${AD_BUILD_WORK_PARTS_DIR}/$1.env.bash)
__EOF__
}


function run_other_chroot_entries {
	local PARTS=($(cat ${AD_BUILD_WORK_PARTS_FILE}))
	cat ${ENV_BASH} | awk '{printf "\t%s\n", $0}'
	for part in "${PARTS[@]}"; do
		[ "${part}" == "${PART_NAME}" ] && continue
		local NEW_ENV_FILE="/tmp/${part}.env.bash"
		local CMD="$0 ${NEW_ENV_FILE} ${part} guest chroot_entry"
		generate_part_bash_env ${part} ${NEW_ENV_FILE}
		INFO "$(YELLOW ${CMD})"
		ELINUX_COMMON_GUEST_LOADER=${PART_NAME} ${CMD}
		local EXIT_CODE=$?
		rm -f ${NEW_ENV_FILE}
		[ "0" != "${EXIT_CODE}" ] && ERR "failed to run chroot_entry() of ${part}, exit: ${EXIT_CODE}" && return ${EXIT_CODE}
	done
	return 0
}


function show_rootfs_sizes {
	[ "true" == "${DRY_RUN}" ] && return 0
	local TMP_FILE=$(mktemp /tmp/XXXXXX)
	du -s -m /* 2>${TMP_FILE} | grep -v "/tmp" | grep -v "/work" | awk '{printf "\t%s\n", $0}'
	local EXIT_CODE=$?
	[ "0" == "${EXIT_CODE}" ] && rm -f ${TMP_FILE} && return 0
	cat ${TMP_FILE}
	rm -f ${TMP_FILE}
	return ${EXIT_CODE}
}


function cleanup_package_caches {
	INFO "before package-cache cleanup"
	show_rootfs_sizes

	run_my_cmd "apt-get clean -y -q && apt-get autoclean -y -q && find /var/lib/apt -type f | xargs rm -f"
	run_my_cmd "rm -rf /var/tmp/*"

	INFO "after package-cache cleanup"
	show_rootfs_sizes
}


#
# The chroot_entry (guest script) running inside qemu with chroot,
# is invoked after following services are performed:
#
#	- elinux-common/run_all_services
#	  # useradd
#	    find ${AD_BUILD_WORK_TOPDIR}/elinux-common/services/useradd/*
#		apply user-add function on each found file
#
# Please note, following variables derived from parent process `emb_apply_parts`
# are reloaded from the generated `env.bash`. These variables are reloaded as 
# relative path in chroot:
# 
#  - AD_BUILD_WORK_TOPDIR
#  - AD_BUILD_WORK_DEBIAN_PKG_LIST
#  - AD_BUILD_WORK_PYTHON2_PKG_LIST
#  - AD_BUILD_WORK_PYTHON3_PKG_LIST
#
#  - CLI_DIR
#  - BASH_UTIL_DIR
#  - ELINUX_TOOLS_DIR
#
function chroot_entry {

	check_environment_variables \
		AD_BUILD_WORK_TOPDIR \
		AD_ROOTFS_DIR \
		AD_BUILD_WORK_DEBIAN_PKG_LIST \
		AD_BUILD_WORK_PYTHON2_PKG_LIST \
		AD_BUILD_WORK_PYTHON3_PKG_LIST \
		AD_BUILD_WORK_PARTS_FILE \
		|| return 1

	install_all_packages || return $?
	run_all_services || return $?
	run_other_chroot_entries || return $?

	# env | sort | grep "^AD_" | awk '{printf "\t%s\n", $0}'

	cleanup_package_caches || return $?
	INFO "end."
	return 0
}
